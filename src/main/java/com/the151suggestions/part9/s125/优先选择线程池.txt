线程状态: 新建状态(New), 可运行状态(Runnable, 运行状态), 阻塞状态(Blocked), 等待状态(Waiting), 结束状态(Terminated).
线程状态只能由新建状态转变成运行状态才可能被阻塞/等待,最后结束.把结束状态转变成新建状态会出现异常(IllegalThreadStateException).

线程运行时间:
    T1: 线程启动时间
    T2: 线程体运行时间
    T3: 线程销毁时间
如果线程不能被重复利用,每次创建一个线程都需要经过启动,运行,销毁3个过程

线程池可以在T1 T3缩短时间,容器启动时,创建足够多的线程,当容器需要时直接从线程池中获得线程,运算出结果,再把线程返回线程池中.

线程池的实现涉及3个名词:
    1. 工作线程(Worker)
        线程池中的线程只有两个状态,可运行状态和等待状态,在没有任务时,处于等待状态,运行时可以循环执行任务.
    2. 任务接口(Task)
        这是每个任务必须实现的接口,以供工作线程调度器调度,主要规定了任务的入口,任务执行完的场景处理,任务的执行状态等.
        任务类型: 有返回值的Callable接口任务  无返回值并兼容旧版本的Runnable接口任务
    3. 任务队列(Work Queue)
        也叫工作队列.用于存放等待处理的任务,一般是BlockingQueue的实现类,用来实现任务的排队处理.BlockingQueue是阻塞式队列,如果队列元素为0,则等待,直到有任务进入为止.

newFixedThreadPool()源码:
使用LinkedBlockingQueue为任务队列管理器,所有等待的线程都会放到该队列中.该队列是阻塞式单端队列.
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

线程池创建过程:创建一个阻塞队列以容纳任务,在第一次执行任务时创建足够多的线程(不超过许可线程数),并处理任务,之后每个工作线程自行从任务队列中获得任务,
直到任务队列中的任务数量为0,此时,线程处于等待状态,一旦有任务再加入到队列中,即唤醒工作线程进行处理,实现线程的可复用性.

使用线程池减少的是线程的创建和销毁时间.比如Servlet,每次请求处理都是一个线程,如果不采用线程池,每次请求都会重新创建一个线程,导致系统性能负荷大,响应效率低,降低了系统的友好性.
